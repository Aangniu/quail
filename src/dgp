#!/usr/bin/env python
import code
# import getopt
import argparse
import importlib
import numpy as np
import os
import sys

import defaultparams as default_deck
import errors
from general import SolverType, PhysicsType

import meshing.common as mesh_common
import meshing.gmsh as mesh_gmsh
import meshing.tools as mesh_tools

import physics.euler.euler as euler
import physics.scalar.scalar as scalar
# import physics.chemistry.chemistry as chemistry

import processing.readwritedatafiles as readwritedatafiles

import solver.DG as DG
import solver.ADERDG as ADERDG


def set_physics(order, basis_type, mesh, physics_type):
    dim = mesh.Dim 

    if PhysicsType[physics_type] == PhysicsType.ConstAdvScalar and dim == 1:
        physics_ref = scalar.ConstAdvScalar1D
    elif PhysicsType[physics_type] == PhysicsType.ConstAdvScalar and dim == 2:
        physics_ref = scalar.ConstAdvScalar2D
    elif PhysicsType[physics_type] == PhysicsType.Burgers and dim == 1:
        physics_ref = scalar.Burgers1D
    elif PhysicsType[physics_type] == PhysicsType.Euler and dim == 1:
        physics_ref = euler.Euler1D
    elif PhysicsType[physics_type] == PhysicsType.Euler and dim == 2:
        physics_ref = euler.Euler2D
    # elif PhysicsType[physics_type] == PhysicsType.Chemistry and dim ==1:
    # 	physics_ref = chemistry.Chemistry1D
    else:
        raise NotImplementedError

    physics = physics_ref(order, basis_type, mesh)

    return physics


def overwrite_params(params, params_new, allow_new_keys=False):
	if params_new is None:
		return params

	for key in params_new:
		if not allow_new_keys and key not in params.keys(): 
			raise KeyError
		params[key] = params_new[key]

	return params


def read_inputs(deck):

	# defaults
	restart_params = default_deck.Restart
	stepper_params = default_deck.TimeStepping
	numerics_params = default_deck.Numerics
	mesh_params = default_deck.Mesh
	physics_params = default_deck.Physics
	IC_params = default_deck.InitialCondition
	exact_params = default_deck.ExactSolution
	BC_params = default_deck.BoundaryConditions
	source_params = default_deck.SourceTerms
	output_params = default_deck.Output

	# overwrite
	try: 
		restart_params = overwrite_params(restart_params, deck.Restart)
	except AttributeError: 
		pass
	try:
		stepper_params = overwrite_params(stepper_params, deck.TimeStepping)
	except AttributeError: 
		pass
	try:
		numerics_params = overwrite_params(numerics_params, deck.Numerics)
	except AttributeError: 
		pass
	try:
		mesh_params = overwrite_params(mesh_params, deck.Mesh)
	except AttributeError: 
		pass
	try:
		physics_params = overwrite_params(physics_params, deck.Physics, True)
	except AttributeError: 
		pass
	try:
		IC_params = overwrite_params(IC_params, deck.InitialCondition, True)
	except AttributeError: 
		pass
	try:
		exact_params = overwrite_params(exact_params, deck.ExactSolution, True)
	except AttributeError: 
		pass
	try:
		BC_params = overwrite_params(BC_params, deck.BoundaryConditions, True)
	except AttributeError: 
		pass
	try:
		source_params = overwrite_params(source_params, deck.SourceTerms, True)
	except AttributeError: 
		pass
	try:
		output_params = overwrite_params(output_params, deck.Output)
	except AttributeError: 
		pass

	return restart_params, stepper_params, numerics_params, mesh_params, physics_params, \
		IC_params, exact_params, BC_params, source_params, output_params


def driver(deck):

	'''
	Input deck
	'''
	restart_params, stepper_params, numerics_params, mesh_params, physics_params, \
			IC_params, exact_params, BC_params, source_params, output_params = read_inputs(deck)


	'''
	Mesh
	'''
	if mesh_params["File"] is not None:
		mesh = mesh_gmsh.ReadGmshFile(mesh_params["File"])
	else:
		# Unpack
		shape = mesh_params["ElementShape"]
		xmin = mesh_params["xmin"]
		xmax = mesh_params["xmax"]
		nElem_x = mesh_params["nElem_x"]
		nElem_y = mesh_params["nElem_y"]
		ymin = mesh_params["ymin"]
		ymax = mesh_params["ymax"]
		if shape is "Segment":
			if mesh_params["PeriodicBoundariesX"] != []:
				periodic = True
			else:
				periodic = False
			mesh = mesh_common.mesh_1D(Uniform=True, nElem=nElem_x, xmin=xmin, xmax=xmax, Periodic=periodic)
		else:
			# 2D - quads or tris
			mesh = mesh_common.mesh_2D(nElem_x=nElem_x, nElem_y=nElem_y, Uniform=True, xmin=xmin, xmax=xmax, 
					ymin=ymin, ymax=ymax)
			periodic=True
			if shape is "Triangle":
				mesh = mesh_common.split_quadrils_into_tris(mesh)

	pb = [None]*4
	# Store periodic boundaries in pb
	i = 0
	for b in mesh_params["PeriodicBoundariesX"]:
		pb[i] = b
		i += 1
	if mesh.Dim == 2:
		i = 2
		for b in mesh_params["PeriodicBoundariesY"]:
			pb[i] = b
			i += 1
	if pb != [None]*4 and mesh.Dim !=1:
		# need to check 1D first
		if mesh.Dim == 1:
			raise Exception
		mesh_tools.MakePeriodicTranslational(mesh, x1=pb[0], x2=pb[1], y1=pb[2], y2=pb[3])

	'''
	Physics
	'''
	# Create physics object
	order = numerics_params["InterpOrder"]
	basis_type = numerics_params["InterpBasis"]
	# if physics_params["Type"] is "ConstAdvScalar":
	# 	if mesh.Dim == 1:
	# 		physics = scalar.ConstAdvScalar1D(order, basis, mesh)
	# 	else:
	# 		physics = scalar.ConstAdvScalar2D(order, basis, mesh)
	# elif physics_params["Type"] is "Burgers":
	# 	if mesh.Dim == 1:
	# 		physics = scalar.Burgers1D(order, basis, mesh)
	# 	else:
	# 		raise NotImplementedError
	# elif physics_params["Type"] is "Euler":
	# 	if mesh.Dim == 1:
	# 		physics = euler.Euler1D(order, basis, mesh)
	# 	else:
	# 		physics = euler.Euler2D(order, basis, mesh)

	physics = set_physics(order, basis_type, mesh, physics_params["Type"])

	# Set parameters
	pparams = physics_params.copy()
	pparams.pop("Type") # don't pass this key
	# physics.SetParams(**pparams)
	conv_flux_type = pparams.pop("ConvFlux")
	physics.set_conv_num_flux(conv_flux_type)
	physics.set_physical_params(**pparams)

	# temporary
	# if IC_params["Function"] is "Gaussian":
	# 	fcn = physics.FcnGaussian
	# 	IC_params["Function"] = fcn
	# else:
	# 	raise Exception

	# Initial condition
	iparams = IC_params.copy()
	IC_type = iparams.pop("Function")
	physics.set_IC(IC_type=IC_type,**iparams)

	# Exact solution
	if bool(exact_params): # checks if dictionary is not empty
		eparams = exact_params.copy()
		exact_type = eparams.pop("Function")
		physics.set_exact(exact_type=exact_type,**eparams)


	# Boundary conditions
	# for BFG in mesh.BFaceGroups:
	for bname, bparams in BC_params.items():
		# bname = BFG.Name
		# bparams = BC_params[bname].copy()
		# bparams.pop("Function")

		# btype = physics.BCType[bparams["BCType"]]
		# bparams.pop("BCType")

		# # EqnSet.set_BC(BC_type="StateAll", fcn_type="DampingSine", omega = 2*np.pi, nu=nu)
		# # bparams["BCType"] = btype
		# # bparams["Function"] = set_function(physics, bparams["Function"])
		# # code.interact(local=locals())

		# EqnSet.set_BC(BC_type="StateAll", fcn_type="SmoothIsentropicFlow", a=0.9)

		###
		# code.interact(local=locals())
		# physics.SetBC(bname, **bparams)

		bparams = bparams.copy()
		
		BC_type = bparams.pop("BCType")

		try:
			fcn_type = bparams.pop("Function")
			physics.set_BC(bname, BC_type, fcn_type, **bparams)
		except KeyError:
			physics.set_BC(bname, BC_type, **bparams)

	# Source terms
	for sparams in source_params.values():
		sname = sparams["Function"]
		sparams.pop("Function")
		physics.set_source(source_type=sname, **sparams)

		# physics.SetSource(**sparams)

	'''
	Solver
	'''
	# Merge solver-related params
	solver_params = {**stepper_params, **numerics_params, **output_params}
	solver_params["RestartFile"] = restart_params["File"]
	solver_type = solver_params.pop("Solver")
	if SolverType[solver_type] is SolverType.DG:
		solver = DG.DG(solver_params, physics, mesh)
	elif SolverType[solver_type] is SolverType.ADERDG:
		solver = ADERDG.ADERDG(solver_params, physics, mesh)
	else: 
		raise NotImplementedError


	'''
	Restart file
	'''
	if restart_params["File"] is not None:
		solver_old = readwritedatafiles.read_data_file(solver_params["RestartFile"])
		# unpack
		physics_old = solver_old.EqnSet
		params_old = solver_old.Params
		# project if different basis and/or order
		if order != physics_old.order or solver.basis.basis_type != solver_old.basis.basis_type:
			print("Projecting to a different solution basis and/or order")
			solver.project_state_to_new_basis(physics_old.U, solver_old.basis, physics_old.order)
		else:
			solver.EqnSet.U = physics_old.U
		if restart_params["StartFromFileTime"]:
			solver.Time = solver_old.Time

	'''
	Run
	'''
	solver.solve()


	return solver, physics, mesh

def process_restart_file(deck, restart_file):
	if restart_file != None:
		try:
			deck.Restart['File'] = restart_file
		except KeyError:
			deck.Restart = {"File": restart_file}

def process_post_file(auto_process, post_file):
	if post_file != None:
		post_file = post_file.replace('.py','')
		try:
			postprocess = importlib.import_module(post_file)
		except ModuleNotFoundError:
			raise errors.FileReadError(f"{post_file}.py not found")
	if auto_process == True and post_file == None:
		post_file = 'post_process'
		try:
			postprocess = importlib.import_module(post_file)
		except ModuleNotFoundError:
			print('Warning: post_process.py file not found')

def main(argv):
	
	inputfile = ''
	postfile = ''

	my_parser = argparse.ArgumentParser(conflict_handler='resolve', description='This script is the driver for Stanford\'s DGP solver')

	# Argument for the input deck
	my_parser.add_argument('inputdeck',
    	                   metavar='inputdeck:',
        	               type=str,
            	           help='this file contains all requested parameters for the solver')
	# Optional argument for the post processing script
	my_parser.add_argument('-p','--post',
    	                   metavar='',
        	               type=str,
            	           help='this file executes post-processing when included in CLI')	

	my_parser.add_argument('-r', '--restart',
							metavar='',
							type=str,
							help='name of restart file')
	my_parser.add_argument('-t','--type',
							choices=['solve','post'],
							help='if post is selected, read in the post-processing file without \'-p\' instead of the inputdeck (solve executes by default)')

	# Execute the parse_args() method
	args = my_parser.parse_args()

	input_deck = args.inputdeck
	post_file = args.post
	restart_file = args.restart

	CurrentDir = os.path.dirname(os.path.abspath(input_deck)) + "/"
	sys.path.append(CurrentDir)

	# Run the primary solver while checking for restart files and post processing files
	if args.type == None or args.type == 'solve':
		input_deck=input_deck.replace('.py','')
		deck = importlib.import_module(input_deck)

		process_restart_file(deck, restart_file)
		solver, physics, mesh = driver(deck)
		auto_process = solver.Params["AutoProcess"]
		process_post_file(auto_process, post_file)

	# Run the post processor without the solver (Requires the [-t post] option in CLI)
	if args.type == 'post':
		post_file = input_deck
		auto_process = True
		process_post_file(auto_process, post_file)

if __name__ == "__main__":
	main(sys.argv[1:])






